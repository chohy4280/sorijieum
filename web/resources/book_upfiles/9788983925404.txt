//-------------------------------------------------------------------------------------
* 상속(Inheritance)
 : 목적 -> 클래스의 재사용 
 - 다른 클래스가 가지고 있는 멤버(필드와 메소드)들을 새로 작성할 클래스에서
  직접 만들지 않고 상속을 받음으로써 새 클래스가 자신의 멤버처럼 사용할 수
  있는 기능.
 - 기능의 중복을 줄이고, 작업시간의 단축 등 많은 장점을 가짐

 => 자바에서의 상속처리
	: 클래스간의 상속시에는 extends 키워드 사용함

	
[public] class 클래스명 extends 클래스명{}
[public] class 클래스명 extends 부모클래스명{}
		    
	상속받는 클래스           상속하는 클래스
		    
	후손/자식/파생클래스   상위/부모/선조/슈퍼클래스
	서브(sub)클래스
	




인터페이스 간의 상속 : extends 사용	
[public] interface 인터페이스명 extends 부모인터페이스명{}


클래스가 인터페이스를 상속받을 때 : implements 사용
[public] class 클래스명 implements 부모인터페이스명{}


 => java.lang.Object 클래스가 자바언어에서의 최상위클래스임. (단군할아버지 급)
 => 자바에서 제공되는 클래스이든, 개발자가 만드는 클래스들 모두 다
    Object 클래스의 후손으로 자동 처리되고 있음 
    : 곧, Object 클래스가 제공하는 메소드는 
     모든 클래스가 자신의 메소드처럼 사용해도 됨.
	* public boolean equals(비교할 레퍼런스) 
		: 두 레퍼런스의 주소가 같은지 물어볼 때
	* public String toString()
		: 클래스명@16진수해시코드 를 리턴함
	* public int hashCode()
		: 할당된 객체의 위치정보를 십진수 해시코드값으로 리턴함



 => 자바는 extends 를 통한 클래스간 상속은 단일상속만 허용함.
    인터페이스간 extends 상속은 다중상속을 허용함.
    클래스가 인터페이스를 상속받는 implements 도 다중상속 허용함

 => 부모클래스의 생성자, 초기화블럭(필드의 초기값 대입 처리하는 블럭)은 상속 안 됨.
	: 후손 클래스 객체생성시, 부모클래스 생성자가 먼저 실행되도록 되어 있음.
	 후손 클래스 생성자 안에서, 부모클래스 생성자 호출을 명시하고 싶으면, super(); 를 입력함.

 => 부모의 private 멤버는 상속은 되나, 후손도 접근 불가능임(오로지 부모 클래스 안에서만 접근 가능)
	후손 객체 생성시에 부모의 필드값도 전달받은 경우
	후손 생성자 안에서 부모의 private 필드에 직접 초기값 대입 못 함
	--> 전달받은 부모 필드값을 부모생성자 쪽으로 넘기는 방법을 씀
	super(전달받은 값, ......);
	// 부모의 매개변수 있는 생성자가 받아서 초기화 시킴.



 => 오버라이딩(Overriding)
	: 후손클래스가 상속받은 부모 메소드를 재작성하는 것
	- 부모가 제공하는 기능을 후손이 일부 고쳐 쓰겠다는 의미임
	- 후손객체를 통한 실행시 후손 것이 우선권을 가짐.
	  부모것은 자동 은닉됨 --> 후손의 오버라이딩된 메소드 안에서
		부모메소드를 호출함.
		--> super.부모의 오버라이딩된 메소드();
	*** 오버라이딩시 부모 메소드의 접근제어자 수정 가능함.
		=> 단, 부모 것보다 넓은 범위로 변경 가능함.
	*** 오버라이딩시 부모 메소드의 예외처리 클래스 갯수보다
		같건, 갯수를 줄일 수 있음


 => super();	//기입시 반드시 첫 줄에만 작성할 수 있음.
		//부모생성자가 가장 먼저 실행이 되어야 하기 때문.

	- 후손클래스 생성자 안에는 첫 줄에 super(); 존재함
		: 후손 객체 생성시 부모부터 생성됨(객체지향의 기본구조)
	- 후손의 매개변수 있는 생성자 작동시 초기값의 일부를 부모쪽으로
	  넘겨야 될 경우, 부모의 매개변수 있는 생성자 쪽으로 넘기면 됨
		super(초기값, 초기값);

	- 자바에서는 모든 클래스가 java.lang.Object 클래스의 후손으로
	  자동 상속되도록 되어 있음.
	  => Object 클래스가 제공하는 있는 메소드를 오버라이딩해서
	    메소드 본래 기능을 변형할 수 있음.
		ex>
		java.lang.String 클래스의 equals() 메소드가 오버라이딩
		되어서 두 객체가 가진 값이 일치하는지 비교하도록
		변경되어 있음.
		toString() 도 오버라이딩해서 문자열값 리턴하는 기능으로
		변경하였음.
	- Annotation : 자바 컴파일러에게 알리는 주석문	
			@Diprecated
			@Override
			@Supress Warning("무시할 경고")무시할 경고문을 입력
			하면 무시가능

	- 오버라이딩시 메소드 해드라인 위에 반드시 Annotation 표시할 것
	@Override
	public 반환형 메소드명([자료형 매개변수]){}

//------------------------------------------------------------------------------------------
	- 자바에서는 클래스 간의 상속에는 단일 상속만 허용함.
	- 다중상속이 필요할 경우에는 상속을 원하는 클래스의 변형인
	  인터페이스를 상속받는 것으로 해결함.
	- 인터페이스는 다중상속을 허용함.

	[public] class 클래스명 extends 부모클래스명 
			implements 부모인터페이스명, 부모인터페이스명
	{}

	ex>
	public class MyMemo extends JFrame 
		implements ActionListener, KeyListener
	{
		윈도우 창 만들기
		메뉴바 만들기
		메뉴항목 만들고, 메뉴바 붙이기 > 메뉴항목 동작처리
		툴바 만들기
		툴버튼 만들고, 
		> 배치할 방법(Layout) 지정
		> 툴바에 붙이기 (배치하기)
		> 툴버튼 동작(Event) 처리

	}

//--------------------------------------------------------------------------------------
	- 추상(abstract) 클래스 : 미완성된 클래스를 의미함
		=> 레퍼런스로는 사용할 수 있지만, 객체 생성은 못 함
		ex>
		추상클래스명 레퍼런스;	//ok
		레퍼런스 = new 추상클래스생성자();	//error

	public abstract class 클래스명
	{}

	- 추상(abstract) 메소드 : 미완성된 메소드
		=> 메소드의 해드만 제공하고, 몸체(body)가 없는 메소드

	public abstract 반환자료형 메소드명([자료형 매개변수]);

	** 추상메소드를 가진 클래스는 반드시 추상클래스가 되어야 함.
		=> 통일된 인터페이스를 제공하기 위함
		=> 어떤 기능 처리용 메소드는 어떤이름으로 어떻게
		   사용할 것인지에 대한 약속(규칙)을 미리 정해놓음.
		=> 정해놓은 규칙을 상속을 통해서 상속받아서 각자
		   정해진 규칙은 따르되, 처리할 내용은 각자의
		   처리내용에 맞게 작성하도록 함.

	- 추상클래스를 상속 받아서, 포함된 추상메소드를 후손이 반드시
	  완성을 시켜야 함 : 오버라이딩(의무사항임 : 재구현해야 함)

	@Override
	public 반환자료형 추상메소드명([자료형 매개변수])
	{  처리할 내용을 작성함     }

	- 인터페이스(interface) : 추상클래스의 변형
		=> 추상메소드로만 구성된 추상클래스 변형임.

	[public] interface 인터페이스명
	{
		상수도 멤버로 포함할 수 있음
		public static final 자료형 변수명 = 초기값;
				     (변수명은 반드시 대문자로)

		추상메소드만 선언됨
		[public abstract] 반환자료형 메소드명([자료형 매개변수]);
		생략됨 : 후손이 오버라이딩할 때는 반드시 public 표기해야 함
	}

	- 인터페이스도 레퍼런스 변수는 선언 가능함.
		인터페이스명 레퍼런스변수;

//------------------------------------------------------------------------------------------
* 다형성(Polymorphism)
	: 여러 종류의 클래스 타입을 처리하는 기술
	- 동일한 기능을 수행하는 메소드가 여러 종류의 클래스들을 처리하려면
	  오버로딩(Overloading)을 사용함. 
		ex>
		public method(A ob){}
		public method(B ob){}
		public method(String ob){}
		public method(Car ob){}
	- 오버로딩(중복 작성)을 줄이면서, 원하는 클래스 타입들을 처리하게
	  하고자 할 경우, 다형성을 이용함.
		ex>
		public method(Object ob){}

	- 상속관계에 있는 클래스들 일 때는 부모형 레퍼런스가 후손의
	  주소를 받을 수 있음.
	ex>
	public class PP{
		public static void testPP(PP pob){}
	}

	public class A extends PP{}
	public class B extends PP{}
	public class C extends PP{}

	=> PP pob;
	   A aob = new A();
	   B bob = new B();
	   C cob = new C();

	   pob = aob;	
	   pob = bob;
	   pob = cob;
	** 자동형변환 적용됨 : 하위클래스형이 상위클래스형에 대입될 경우
			후손타입이 부모타입으로 바뀌면서 대입됨.
			--> UpCasting 이라고 함.

	** 부모타입을 후손타입으로 바꾸는 경우 : 직접 변환해야 함
					(강제/명시적 형변환)
			--> DownCasting 이라고 함.
		((후손클래스형)부모레퍼런스)


	ex>
	PP.testPP(aob);  //A클래스형 aob를 메소드 매개변수가
			//PP클래스형 pob가 받음 : 다형성 적용됨
	PP.testPP(bob);
	PP.testPP(cob);

	=> testPP() 메소드 안에서, 부모레퍼런스 pob가 받은 주소정보를
	   각 후손클래스 타입으로 바꿔야 되는 경우에는 클래스형을
	   확인하고 그 클래스가 맞으면 해당 클래스형으로 형변환함.
		: instanceof 연산자 사용함.

	if(부모레퍼런스 instanceof 후손클래스명)
	{
		(후손클래스)부모레퍼런스 //형변환함.
	}

	ex>
	public void testPP(PP pob)
	{
		//DownCasting을 해야 할 경우
		if(pob instanceof A)
		{
			(A)pob
		}else if(pob instanceof B)
		{
			(B)pob
		}else if(pob instanceof C)
		{
			(C)pob
		}
	}








